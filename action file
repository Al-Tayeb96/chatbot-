from typing import Any, Text, Dict, List, Optional
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.events import FollowupAction
from rasa_sdk.events import SlotSet
from langdetect import detect
from rapidfuzz import fuzz, process
from .main_menu_ar import main_menu_ar
from .main_menu_en import main_menu_en
from .intent_submenu_map import intent_to_submenu_map
from rasa_sdk.types import DomainDict
import logging
import re

logger = logging.getLogger(__name__)
class ActionDetectLanguage(Action):
    def name(self) -> Text:
        return "action_detect_language"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        current_lang = tracker.get_slot("language")
        print(f"[DEBUG] Current language slot: {current_lang}")

        # Ø¥Ø°Ø§ Ø§Ù„Ù„ØºØ© Ù…Ø¹Ø±ÙˆÙØ© Ù…Ø³Ø¨Ù‚Ù‹Ø§ Ù„Ø§ ØªØºÙŠØ±Ù‡Ø§
        if current_lang in ["ar", "en"]:
            print("[DEBUG] Language already set, skipping detection.")
            return []

        user_message = tracker.latest_message.get("text", "")
        print(f"[DEBUG] User message: {user_message}")

        try:
            detected_lang = detect(user_message)
            print(f"[DEBUG] Detected language: {detected_lang}")
            lang = "ar" if detected_lang == "ar" else "en"
        except Exception as e:
            print(f"[DEBUG] Language detection failed: {e}")
            lang = "ar"  # fallback

        print(f"[DEBUG] Setting language slot to: {lang}")
        return [SlotSet("language", lang)]


class ActionSwitchLanguage(Action):
    def name(self) -> Text:
        return "action_switch_language"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        user_text = tracker.latest_message.get("text", "").lower().strip()
        print(f"[DEBUG] User requested language switch: {user_text}")

        keywords = {
            "ar": ["Ø¹Ø±Ø¨ÙŠ", "Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "Ø¹Ø±Ø¨", "Ø¹Ø±Ø¨ÙŠØ©", "arabic", "arab","AR"],
            "en": ["english", "Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ", "Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©", "Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©", "Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠ","ENG","EN","Ø¥Ù†Ø¬Ù„ÙŠØ´", "Ø§Ù†Ø¬Ù„ÙŠØ²"]
        }

        new_lang = None
        if any(k in user_text for k in keywords["ar"]):
            new_lang = "ar"
        elif any(k in user_text for k in keywords["en"]):
            new_lang = "en"

        if not new_lang:
            msg = "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ù„ØºØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©." if tracker.get_slot("language") == "ar" \
                  else "âŒ Could not detect the requested language."
            dispatcher.utter_message(text=msg)
            print(f"[DEBUG] Language not recognized, message sent: {msg}")
            return []

        print(f"[DEBUG] Switching language to: {new_lang}")

        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        main_menu = get_main_menu(tracker, language=new_lang)
        TITLES, EMOJIS = get_titles_emojis(new_lang)
        menu_data = list_options("main", main_menu=main_menu, TITLES=TITLES, EMOJIS=EMOJIS, language=new_lang)

        # Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯
        confirmation_msg = "ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© âœ…" if new_lang == "ar" else "Switched to English âœ…"
        dispatcher.utter_message(text=confirmation_msg)
        print(f"[DEBUG] Confirmation message sent: {confirmation_msg}")

        # Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        dispatcher.utter_message(text=menu_data["text"], buttons=menu_data.get("buttons", []))
        print(f"[DEBUG] Main menu displayed: {menu_data}")

        return [
            SlotSet("language", new_lang),
            SlotSet("current_menu", "main"),
            SlotSet("current_submenu", None),
            SlotSet("menu_path_history", []),
            SlotSet("awaiting_confirmation", False)
        ]




# Ø§Ù„Ø£ÙƒØ´Ù†Ø§Øª Ø§Ù„Ø¨Ø³ÙŠØ·Ø© ÙÙ‚Ø· ØªØ³ØªØ¯Ø¹ÙŠ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ù…Ù† domain Ø­Ø³Ø¨ Ù„ØºØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:
class ActionGreet(Action):
    def name(self) -> Text:
        return "action_greet"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        print("[DEBUG] ActionGreet triggered")
        dispatcher.utter_message(response="utter_greet")
        return []


class ActionGoodbye(Action):
    def name(self) -> Text:
        return "action_goodbye"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        print("[DEBUG] ActionGoodbye triggered")
        dispatcher.utter_message(response="utter_goodbye")
        return []


class ActionAskHowAreYou(Action):
    def name(self) -> Text:
        return "action_ask_how_are_you"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        print("[DEBUG] ActionAskHowAreYou triggered")
        dispatcher.utter_message(response="utter_ask_how_are_you")
        return []


class ActionBotIdentity(Action):
    def name(self) -> Text:
        return "action_bot_identity"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        language = tracker.get_slot("language")
        print(f"[DEBUG] ActionBotIdentity triggered | Current language slot: {language}")
        dispatcher.utter_message(response="utter_bot_identity")
        return []


class ActionThankYou(Action):
    def name(self) -> Text:
        return "action_thank_you"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        print("[DEBUG] ActionThankYou triggered")
        dispatcher.utter_message(response="utter_thank_you")
        return []


# Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„ØºØ±Ø¨ÙŠØ© Ø¥Ø°Ø§ Ø§Ø­ØªØ¬Øª ÙÙŠ Ø£ÙŠ Ù…ÙƒØ§Ù†
ARABIC_TO_WESTERN = str.maketrans("Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©", "0123456789")

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù„ØºØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©
SUPPORTED_LANGUAGES = {"ar", "en"}

# Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ù…Ù„Ù main_menu Ø­Ø³Ø¨ Ø§Ù„Ù„ØºØ©
def get_main_menu(tracker: Tracker, language=None) -> Dict[str, Any]:
    language = language or tracker.get_slot("language") or "ar"
    if language not in SUPPORTED_LANGUAGES:
        print(f"[DEBUG] Unsupported language '{language}', defaulting to Arabic")
        language = "ar"
    else:
        print(f"[DEBUG] Loading main menu for language: {language}")

    if language == "ar":
        menu = main_menu_ar
    else:
        menu = main_menu_en

    print(f"[DEBUG] Main menu loaded: {list(menu.keys())}")
    return menu

# Ø¯Ø§Ù„Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
def get_titles_emojis(language: str):
    print(f"[DEBUG] Getting titles and emojis for language: {language}")

    if language == "en":
        TITLES = {
            "1": "Accounts",
            "2": "Transfers",
            "3": "Instant Transfers",
            "4": "Cards",
            "5": "Facilities",
            "6": "E-Services",
            "7": "E-Payments",
            "8": "Checks",
            "9": "Branches & ATMs",
            "10": "Other Services",
        }
        EMOJIS = {
            "1": "ğŸ“œ",
            "2": "ğŸ’¸",
            "3": "âš¡",
            "4": "ğŸ’³",
            "5": "ğŸ’¼",
            "6": "ğŸŒ",
            "7": "ğŸ–¥ï¸",
            "8": "ğŸ“",
            "9": "ğŸ¦",
            "10": "ğŸ“Œ",
        }
    else:
        TITLES = {
            "1": "Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª",
            "2": "Ø§Ù„Ø­ÙˆØ§Ù„Ø§Øª",
            "3": "Ø§Ù„Ø­ÙˆØ§Ù„Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ©",
            "4": "Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª",
            "5": "Ø§Ù„ØªØ³Ù‡ÙŠÙ„Ø§Øª",
            "6": "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©",
            "7": "Ø§Ù„Ø³Ø¯Ø§Ø¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
            "8": "Ø§Ù„Ø´ÙŠÙƒØ§Øª",
            "9": "Ø§Ù„ÙØ±ÙˆØ¹ ÙˆØ§Ù„ØµØ±Ø§ÙØ§Øª",
            "10": "Ø®Ø¯Ù…Ø§Øª Ø£Ø®Ø±Ù‰",
        }
        EMOJIS = {
            "1": "ğŸ“œ",
            "2": "ğŸ’¸",
            "3": "âš¡",
            "4": "ğŸ’³",
            "5": "ğŸ’¼",
            "6": "ğŸŒ",
            "7": "ğŸ–¥ï¸",
            "8": "ğŸ“",
            "9": "ğŸ¦",
            "10": "ğŸ“Œ",
        }

    print(f"[DEBUG] TITLES: {TITLES}")
    print(f"[DEBUG] EMOJIS: {EMOJIS}")
    return TITLES, EMOJIS
def list_options(
    menu_key: Optional[str] = None,
    main_menu: Optional[Dict[str, Any]] = None,
    TITLES: Optional[Dict[str, str]] = None,
    EMOJIS: Optional[Dict[str, str]] = None,
    submenu: Optional[List[Dict[str, Any]]] = None,
    language: str = "ar"
) -> Dict[str, Any]:

    is_ar = language == "ar"
    if TITLES is None or EMOJIS is None:
        TITLES, EMOJIS = get_titles_emojis(language)

    print(f"[DEBUG] list_options called | language: {language}, menu_key: {menu_key}, submenu: {bool(submenu)}")

    def resolve_service_title() -> str:
        if menu_key:
            service_title = TITLES.get(str(menu_key))
            if service_title:
                return service_title
            if main_menu and menu_key in main_menu:
                title_dict = main_menu[menu_key].get("title")
                if isinstance(title_dict, dict):
                    return title_dict.get(language, str(menu_key))
                elif isinstance(title_dict, str):
                    return title_dict
            return str(menu_key)
        return ""

    # Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ© Ù…Ø­Ø¯Ø¯Ø©
    if submenu is not None:
        service_title = resolve_service_title()
        print(f"[DEBUG] Submenu detected | service_title: {service_title} | options_count: {len(submenu)}")
        lines = [
            f"ğŸ•½ï¸ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ø®Ø¯Ù…Ø© :" if is_ar else f"ğŸ•½ï¸ Available options for service :"
        ]
        for i, item in enumerate(submenu, 1):
            title = item.get("title") or item.get("text") or f"Option {i}"
            if isinstance(title, dict):
                title = title.get(language, f"Option {i}")
            else:
                title = str(title)
            lines.append(f"{i}. {title}")
        back_title = "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if is_ar else "0. Back ğŸ”™"
        return {"text": "\n".join(lines), "buttons": [{"title": back_title, "payload": "0"}]}

    # Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    if menu_key == "main" or menu_key is None:
        print("[DEBUG] Displaying main menu")
        lines = ["ğŸ“‹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¨Ù†ÙƒÙŠØ©:" if is_ar else "ğŸ“‹ Main banking services menu:"]
        for k, v in TITLES.items():
            emoji = EMOJIS.get(k, "")
            lines.append(f"{k}. {v} {emoji}")
        lines.append("ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… Ø§Ù„Ø®Ø¯Ù…Ø© Ø£Ùˆ Ø§Ø³Ù…Ù‡Ø§." if is_ar else "Please choose the number or name of the service.")
        return {"text": "\n".join(lines), "buttons": []}

    # Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ© Ù…Ù† main_menu[menu_key]
    menu = main_menu.get(menu_key, {})
    title_dict = menu.get("title", "")
    if isinstance(title_dict, dict):
        title = title_dict.get(language, "")
    else:
        title = str(title_dict)

    options = menu.get("options", {})
    print(f"[DEBUG] Displaying submenu | title: {title} | options_count: {len(options)}")
    lines = [f"ğŸ“‹ {title}:"]
    for k, opt in options.items():
        text_dict = opt.get("text", "")
        if isinstance(text_dict, dict):
            text = text_dict.get(language, "")
        else:
            text = str(text_dict)
        lines.append(f"{k}. {text}")

    back_title = "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if is_ar else "0. Back ğŸ”™"
    return {"text": "\n".join(lines), "buttons": [{"title": back_title, "payload": "0"}]}

def normalize_arabic(text: str) -> str:
    text = text.strip().lower()
    text = text.replace("Ø£", "Ø§").replace("Ø¥", "Ø§").replace("Ø¢", "Ø§")
    text = re.sub(r"[\u0617-\u061A\u064B-\u0652]", "", text)  # ØªØ´ÙƒÙŠÙ„
    text = re.sub(r"[^\w\s]", "", text)  # Ø±Ù…ÙˆØ²
    text = text.replace("Ù‰", "ÙŠ")
    return text




def search_all_levels(user_message: str, menu: Dict[str, Any], threshold: int = 75) -> Optional[Dict[str, Any]]:
    user_message_norm = normalize_arabic(user_message)
    print(f"[DEBUG] Normalized user message: {user_message_norm}")
    best_match = None
    best_score = 0

    def recursive_search(options: Dict[str, Any], level=0):
        nonlocal best_match, best_score
        for key, item in options.items():
            if not isinstance(item, dict):
                continue
            for candidate in (item.get("title", ""), item.get("text", "")):
                candidate_norm = normalize_arabic(candidate)
                score = fuzz.token_set_ratio(user_message_norm, candidate_norm)
                print(f"{'  '*level}[DEBUG] Checking candidate: '{candidate_norm}' | score: {score}")
                if score > best_score and score >= threshold:
                    best_match = item
                    best_score = score
            if "submenu" in item and isinstance(item["submenu"], list):
                recursive_search({str(i): v for i, v in enumerate(item["submenu"])}, level+1)
            if "options" in item and isinstance(item["options"], dict):
                recursive_search(item["options"], level+1)

    recursive_search(menu)
    print(f"[DEBUG] Best match: {best_match} | Score: {best_score}")
    return best_match


def get_node_by_path(menu: Dict[str, Any], path: List[Any]) -> Optional[Dict[str, Any]]:
    node = menu
    for i, step in enumerate(path):
        print(f"[DEBUG] Step {i}: {step} | Current node type: {type(node).__name__}")
        if node is None:
            return None
        if isinstance(step, str):
            node = node.get(step) if step != "submenu" else node.get("submenu", [])
        elif isinstance(step, int):
            if isinstance(node, list) and 0 <= step < len(node):
                node = node[step]
            else:
                print(f"[DEBUG] Invalid index {step} for node {node}")
                return None
        else:
            print(f"[DEBUG] Invalid step type: {type(step).__name__}")
            return None
    print(f"[DEBUG] Node found at path: {node}")
    return node

class ActionOpenMenu(Action):
    def name(self) -> Text:
        return "action_open_menu"

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        language = tracker.get_slot("language") or "ar"
        main_menu = get_main_menu(tracker)  # ØªØ±Ø¬Ø¹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø­Ø³Ø¨ Ø§Ù„Ù„ØºØ©
        TITLES, EMOJIS = get_titles_emojis(language)

        menu_data = list_options("main", main_menu=main_menu, TITLES=TITLES, EMOJIS=EMOJIS, language=language)
        dispatcher.utter_message(text=menu_data["text"], buttons=menu_data.get("buttons", []))

        return [
            SlotSet("current_menu", "main"),
            SlotSet("current_submenu", None),
            SlotSet("current_menu_section", None),
            SlotSet("menu_path_history", []),
            SlotSet("awaiting_confirmation", False,50)
        ]

class ActionHandleMenuOption(Action):
    def name(self) -> Text:
        return "action_handle_menu_option"

    # Ø¯Ø§Ù„Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„ØªÙŠ ØªØ¹Ø¨Ø± Ø¹Ù† Ø£Ø±Ù‚Ø§Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 10 (Ø¹Ø±Ø¨ÙŠØ© ÙˆØ¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©) Ø¥Ù„Ù‰ Ø±Ù‚Ù… ØµØ­ÙŠØ­
    def normalize_text_number(self, text: str) -> Optional[int]:
        ARABIC_NUMBER_MAP = {
            # ÙƒÙ„Ù…Ø§Øª Ø¹Ø±Ø¨ÙŠØ© Ù„Ù„Ø£Ø±Ù‚Ø§Ù…
            "ÙˆØ§Ø­Ø¯": 1, "Ø§ÙˆÙ„": 1, "Ø§Ù„Ø£ÙˆÙ„": 1, "Ø§Ù„Ø£ÙˆÙ„Ù‰": 1, "Ø§ï»·ÙˆÙ„": 1,
            "Ø§Ø«Ù†Ø§Ù†": 2, "Ø§Ø«Ù†ÙŠÙ†": 2, "Ø§ØªÙ†ÙŠÙ†": 2, "Ø«Ø§Ù†ÙŠ": 2, "Ø«Ø§Ù†ÙŠØ©": 2, "Ø§Ù„Ø«Ø§Ù†ÙŠØ©": 2, "Ø§Ù„Ø«Ø§Ù†ÙŠ": 2,
            "Ø«Ù„Ø§Ø«Ø©": 3, "Ø«Ø§Ù„Ø«": 3, "Ø§Ù„Ø«Ø§Ù„Ø«": 3, "Ø«Ø§Ù„Ø«Ø©": 3, "Ø§Ù„Ø«Ø§Ù„Ø«Ø©": 3,
            "Ø£Ø±Ø¨Ø¹Ø©": 4, "Ø±Ø§Ø¨Ø¹": 4, "Ø§Ù„Ø±Ø§Ø¨Ø¹": 4, "Ø±Ø§Ø¨Ø¹Ø©": 4, "Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©": 4,
            "Ø®Ù…Ø³Ø©": 5, "Ø®Ø§Ù…Ø³": 5, "Ø§Ù„Ø®Ø§Ù…Ø³": 5, "Ø®Ø§Ù…Ø³Ø©": 5, "Ø§Ù„Ø®Ø§Ù…Ø³Ø©": 5,
            "Ø³ØªØ©": 6, "Ø³Ø§Ø¯Ø³": 6, "Ø§Ù„Ø³Ø§Ø¯Ø³": 6, "Ø³Ø§Ø¯Ø³Ø©": 6, "Ø§Ù„Ø³Ø§Ø¯Ø³Ø©": 6,
            "Ø³Ø¨Ø¹Ø©": 7, "Ø³Ø§Ø¨Ø¹": 7, "Ø§Ù„Ø³Ø§Ø¨Ø¹": 7, "Ø³Ø§Ø¨Ø¹Ø©": 7, "Ø§Ù„Ø³Ø§Ø¨Ø¹Ø©": 7,
            "Ø«Ù…Ø§Ù†ÙŠØ©": 8, "Ø«Ø§Ù…Ù†": 8, "Ø§Ù„Ø«Ø§Ù…Ù†": 8, "Ø«Ø§Ù…Ù†Ø©": 8, "Ø§Ù„Ø«Ø§Ù…Ù†Ø©": 8,
            "ØªØ³Ø¹Ø©": 9, "ØªØ§Ø³Ø¹": 9, "Ø§Ù„ØªØ§Ø³Ø¹": 9, "ØªØ§Ø³Ø¹Ø©": 9, "Ø§Ù„ØªØ§Ø³Ø¹Ø©": 9,
            "Ø¹Ø´Ø±Ø©": 10, "Ø¹Ø§Ø´Ø±": 10, "Ø§Ù„Ø¹Ø§Ø´Ø±": 10, "Ø¹Ø§Ø´Ø±Ø©": 10, "Ø§Ù„Ø¹Ø§Ø´Ø±Ø©": 10,

            # Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ø£Ø±Ù‚Ø§Ù… Ø¹Ø±Ø¨ÙŠØ© Ø´Ø±Ù‚ÙŠØ©)
            "Ù ": 0,
            "Ù¡": 1,
            "Ù¢": 2,
            "Ù£": 3,
            "Ù¤": 4,
            "Ù¥": 5,
            "Ù¦": 6,
            "Ù§": 7,
            "Ù¨": 8,
            "Ù©": 9
        }

        ENGLISH_NUMBER_MAP = {
            "one": 1, "first": 1,
            "two": 2, "second": 2,
            "three": 3, "third": 3,
            "four": 4, "fourth": 4,
            "five": 5, "fifth": 5,
            "six": 6, "sixth": 6,
            "seven": 7, "seventh": 7,
            "eight": 8, "eighth": 8,
            "nine": 9, "ninth": 9,
            "ten": 10, "tenth": 10,
        }

        text = text.lower().strip()
        print(f"DEBUG normalize_text_number called with text='{text}'")

        # 1. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ‚Ø§Ø· Ø±Ù‚Ù… Ù…Ø¨Ø§Ø´Ø±
        match = re.search(r"\b\d+\b", text)
        if match:
            num = int(match.group())
            print(f"DEBUG Direct number detected: {num}")
            if 1 <= num <= 10:
                return num

        # 2. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø·Ø§Ø¨Ù‚Ø© ØºØ§Ù…Ø¶Ø© Ù…Ø¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
        best_match_ar = process.extractOne(text, ARABIC_NUMBER_MAP.keys(), scorer=fuzz.partial_ratio)
        print(f"DEBUG Arabic fuzzy match: {best_match_ar}")
        if best_match_ar and best_match_ar[1] >= 85:
            return ARABIC_NUMBER_MAP[best_match_ar[0]]

        # 3. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø·Ø§Ø¨Ù‚Ø© ØºØ§Ù…Ø¶Ø© Ù…Ø¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
        best_match_en = process.extractOne(text, ENGLISH_NUMBER_MAP.keys(), scorer=fuzz.partial_ratio)
        print(f"DEBUG English fuzzy match: {best_match_en}")
        if best_match_en and best_match_en[1] >= 85:
            return ENGLISH_NUMBER_MAP[best_match_en[0]]

        print("DEBUG No valid number match found")
        return None

    # Ø¯Ø§Ù„Ø© Ù„Ù„Ø¨Ø­Ø« Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø±
    def _get_option_by_path(self, menu: Dict[str, Any], path: List[Any]) -> Optional[Dict[str, Any]]:
        print(f"DEBUG _get_option_by_path called with path={path}")
        node = menu.get(path[0])
        for step in path[1:]:
            print(f"DEBUG Traversing step={step}, current_node={node}")
            if node is None:
                print("DEBUG Node is None â†’ returning None")
                return None
            if isinstance(step, str):
                if isinstance(node, dict):
                    node = node.get(step)
                    print(f"DEBUG Step is str, moved to node={node}")
                else:
                    print("DEBUG Step is str but node not dict â†’ returning None")
                    return None
            elif isinstance(step, int):
                if isinstance(node, list) and 0 <= step < len(node):
                    node = node[step]
                    print(f"DEBUG Step is int, moved to node={node}")
                else:
                    print("DEBUG Step is int but invalid index/list â†’ returning None")
                    return None
            else:
                print("DEBUG Step type not supported â†’ returning None")
                return None
        print(f"DEBUG Final node={node}")
        return node


    # Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ù…Ø®ØªØ§Ø± (Ø¹Ø±Ø¶ Ù†ØµØŒ Ø±ÙˆØ§Ø¨Ø·ØŒ ÙÙŠØ¯ÙŠÙˆØŒ Ø¥Ù„Ø®)
    def _handle_leaf_option(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            option: Dict[str, Any],
            language: str,
            path_history: List[str],
            option_key: Optional[str] = None
    ) -> List[Dict[Text, Any]]:
        title = option.get("text") or option.get("title") or ("Ø§Ù„Ø®Ø¯Ù…Ø©" if language == "ar" else "Service")
        updated_history = path_history.copy()
        if option_key:
            updated_history.append(option_key)

        # Ø£ÙˆØ§Ù…Ø± Ø®Ø§ØµØ© (Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø£Ùˆ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©)
        if option.get("action") in {"back_to_main", "back"}:
            if option["action"] == "back_to_main":
                TITLES, EMOJIS = get_titles_emojis(language)
                main_menu = get_main_menu(tracker)
                menu_data = list_options("main", main_menu=main_menu, TITLES=TITLES, EMOJIS=EMOJIS, language=language)
                dispatcher.utter_message(text=menu_data["text"], buttons=menu_data.get("buttons", []))
                return [
                    SlotSet("current_menu", "main"),
                    SlotSet("current_submenu", None),
                    SlotSet("menu_path_history", []),
                    SlotSet("awaiting_confirmation", False)
                ]
            else:
                return [FollowupAction("action_back")]

        # Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ©
        if "submenu" in option and option["submenu"]:
            service_title = option_key or option.get("title") or option.get("text") or (
                "Ø§Ù„Ø®Ø¯Ù…Ø©" if language == "ar" else "Service")
            submenu_data = list_options(
                submenu=option["submenu"],
                language=language,
                menu_key=service_title
            )
            dispatcher.utter_message(text=submenu_data["text"], buttons=submenu_data.get("buttons", []))
            return [
                SlotSet("current_submenu", option["submenu"]),
                SlotSet("current_menu_section", service_title),
                SlotSet("menu_path_history", path_history + [service_title])
            ]

        # Ù‚Ø§Ø¦Ù…Ø© Ø®ÙŠØ§Ø±Ø§Øª ÙØ±Ø¹ÙŠØ©
        if "options" in option and isinstance(option["options"], dict):
            submenu_list = list(option["options"].values())
            submenu_data = list_options(
                submenu=submenu_list,
                language=language,
                menu_key=option_key
            )
            dispatcher.utter_message(text=submenu_data["text"], buttons=submenu_data.get("buttons", []))
            return [
                SlotSet("current_submenu", submenu_list),
                SlotSet("menu_path_history", updated_history)
            ]

        # Ø±ÙˆØ§Ø¨Ø·ØŒ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§ØªØŒ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù†ØµÙŠØ© Ø£Ùˆ Ø£ÙØ¹Ø§Ù„ Ù†Ù‡Ø§Ø¦ÙŠØ©
        if any(key in option for key in ("link", "youtube", "text_info", "action")):
            if "link" in option:
                dispatcher.utter_message(
                    text=(f"ğŸ”— Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø®Ø¯Ù…Ø© {title}ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:" if language == "ar"
                          else f"ğŸ”— To access {title} service, please click the button below:"),
                    buttons=[
                        {"title": (f"ÙØªØ­ Ø±Ø§Ø¨Ø· {title}" if language == "ar" else f"Open {title} link"),
                         "url": option["link"], "type": "web_url"},
                        {"title": "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if language == "ar" else "0. Back ğŸ”™", "payload": "0"},
                    ],
                )
            elif "youtube" in option:
                dispatcher.utter_message(
                    text=(f"ğŸ¥ Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© ÙÙŠØ¯ÙŠÙˆ Ø­ÙˆÙ„ Ø®Ø¯Ù…Ø© {title}ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:" if language == "ar"
                          else f"ğŸ¥ To watch a video about {title}, please click the button below:"),
                    buttons=[
                        {"title": (f"Ù…Ø´Ø§Ù‡Ø¯Ø© {title}" if language == "ar" else f"Watch {title}"),
                         "url": option["youtube"], "type": "web_url"},
                        {"title": "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if language == "ar" else "0. Back ğŸ”™", "payload": "0"},
                    ],
                )
            elif "text_info" in option:
                buttons = option.get("buttons") or []
                buttons.append({"title": "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if language == "ar" else "0. Back ğŸ”™", "payload": "0"})
                dispatcher.utter_message(
                    text=option["text_info"],
                    buttons=buttons
                )
            elif "action" in option:
                action_name = option["action"]
                # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ø³Ù… Ø§Ù„Ø§ÙƒØ´Ù† Rasa Action
                if action_name.startswith("action_") or action_name.startswith("request_"):
                    return [FollowupAction(action_name)]
                else:
                    dispatcher.utter_message(
                        text=action_name,
                        buttons=[
                            {"title": "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if language == "ar" else "0. Back ğŸ”™", "payload": "0"}
                        ],
                    )

            dispatcher.utter_message(response="utter_ask_more_help")
            return [
                SlotSet("current_submenu", tracker.get_slot("current_submenu")),
                SlotSet("menu_path_history", updated_history),
                SlotSet("awaiting_confirmation", True, 50)
            ]

        # Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ØªØ§Ø­Ø©
        dispatcher.utter_message(
            text=(f"âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ØªØ§Ø­Ø© Ù„Ø®Ø¯Ù…Ø© {title}." if language == "ar"
                  else f"âŒ No information available for {title}."),
            buttons=[{"title": "0. Ø±Ø¬ÙˆØ¹ ğŸ”™" if language == "ar" else "0. Back ğŸ”™", "payload": "0"}],
        )
        dispatcher.utter_message(response="utter_ask_more_help")
        return [
            SlotSet("current_submenu", None),
            SlotSet("menu_path_history", updated_history),
            SlotSet("awaiting_confirmation", True, 50)
        ]

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        language = tracker.get_slot("language") or "ar"
        main_menu = get_main_menu(tracker)
        TITLES, EMOJIS = get_titles_emojis(language)

        user_message = tracker.latest_message.get("text", "").strip()
        user_intent = tracker.latest_message.get("intent", {}).get("name")

        current_menu = tracker.get_slot("current_menu") or "main"
        current_submenu = tracker.get_slot("current_submenu")
        current_menu_section = tracker.get_slot("current_menu_section")  # <-- Ø¥Ø¶Ø§ÙØ© Ø§Ø³ØªØ±Ø¬Ø§Ø¹ slot Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù… Ø§Ù„ÙØ±Ø¹ÙŠ
        path_history = tracker.get_slot("menu_path_history") or []

        # Ø¬Ù„Ø¨ ÙƒÙŠØ§Ù† option Ø¥Ø°Ø§ ÙˆØ¬Ø¯
        option_entity = next(tracker.get_latest_entity_values("option"), None)
        normalized_option = self.normalize_text_number(option_entity or user_message)

        # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ© Ø¹Ø¨Ø± Ø§Ù„Ù†ÙˆØ§ÙŠØ§
        if user_intent in intent_to_submenu_map:
            submenu_info = intent_to_submenu_map[user_intent]
            menu_key = submenu_info["menu_key"]
            path = submenu_info.get("path", [])
            menu_section = main_menu.get(menu_key, {})

            # Ø¬Ù„Ø¨ Ø§Ù„Ø®ÙŠØ§Ø± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ÙƒØ§Ù…Ù„
            option = self._get_option_by_path(menu_section, path) if path else menu_section

            if option:
                if menu_key not in path_history:
                    path_history.append(menu_key)
                # Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø¯Ù…Ø© Ø£Ùˆ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©
                return self._handle_leaf_option(dispatcher, tracker, option, language, path_history,
                                                option_key=path[-1] if path else menu_key)

        # Ø£Ù…Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹
        if user_message == "Ù "or user_message == "0":
            return ActionBack().run(dispatcher, tracker, domain)

        print(f"DEBUG current_submenu: {current_submenu}")
        print(f"DEBUG current_menu_section: {current_menu_section}")
        print(f"DEBUG option_entity: {option_entity}")
        print(f"DEBUG user_message: '{user_message}'")
        print(f"DEBUG normalized_option: {normalized_option}")

        # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ current_submenu Ù„ÙƒÙ† ÙŠÙˆØ¬Ø¯ current_menu_sectionØŒ Ù†Ø¹ÙŠØ¯ Ø¨Ù†Ø§Ø¡ current_submenu Ù…Ù† main_menu
        if not current_submenu and current_menu_section:
            section = main_menu.get(current_menu_section)
            if section and "submenu" in section:
                current_submenu = section["submenu"]
                print(
                    f"DEBUG Rebuilt current_submenu from current_menu_section '{current_menu_section}' with {len(current_submenu)} options.")

        # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø¥Ù† ÙˆØ¬Ø¯Øª)
        if current_submenu:
            if normalized_option and 1 <= normalized_option <= len(current_submenu):
                item = current_submenu[normalized_option - 1]
                return self._handle_leaf_option(dispatcher, tracker, item, language, path_history)
            print(f"DEBUG: Current submenu detected with {len(current_submenu)} options.")
            for idx, item in enumerate(current_submenu, 1):
                title = item.get("title") or item.get("text")
                if isinstance(title, dict):
                    title = title.get(language, "")
                if user_message == str(idx):
                    return self._handle_leaf_option(dispatcher, tracker, item, language, path_history)
                if fuzz.token_set_ratio(user_message.lower(), title.lower()) >= 75:
                    return self._handle_leaf_option(dispatcher, tracker, item, language, path_history)

        # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ©
        if current_menu == "main" and not current_submenu:
            options = main_menu

            # Ø¥Ø°Ø§ ØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø®ÙŠØ§Ø± ØµØ­ÙŠØ­
            if normalized_option and 1 <= normalized_option <= len(options):
                option_items = list(options.items())
                selected_key, selected_option = option_items[normalized_option - 1]
                # Ù…Ù‡Ù…: Ù‡Ù†Ø§ ÙŠØ¬Ø¨ Ø­ÙØ¸ current_menu_section Ø¹Ù†Ø¯ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
                return self._handle_leaf_option(dispatcher, tracker, selected_option, language, path_history,
                                                option_key=selected_key)

            # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø±Ù‚Ù…ÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©
            if user_message.isdigit():
                index = int(user_message)
                option_items = list(options.items())
                if 1 <= index <= len(option_items):
                    selected_key, selected_option = option_items[index - 1]
                    # Ø­ÙØ¸ current_menu_section Ø¹Ù†Ø¯ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ©
                    return self._handle_leaf_option(dispatcher, tracker, selected_option, language, path_history,
                                                    option_key=selected_key)

            # ØªØ­Ù‚Ù‚ Ø§Ù„ØªØ·Ø§Ø¨Ù‚ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ù†Øµ
            for key, opt in options.items():
                opt_intent = opt.get("intent")
                opt_text = opt.get("title", {})
                text_value = opt_text.get(language, "") if isinstance(opt_text, dict) else opt_text
                if opt_intent and user_intent == opt_intent:
                    return self._handle_leaf_option(dispatcher, tracker, opt, language, path_history, option_key=key)
                if fuzz.token_set_ratio(user_message.lower(), text_value.lower()) >= 75:
                    return self._handle_leaf_option(dispatcher, tracker, opt, language, path_history, option_key=key)

            # ØªØ­Ù‚Ù‚ Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù†ØµÙˆØµ ÙÙŠ Ø­Ù‚Ù„ "text"
            for key, opt in options.items():
                opt_text = opt.get("text", {})
                text_value = opt_text.get(language, "") if isinstance(opt_text, dict) else opt_text
                if fuzz.token_set_ratio(user_message.lower(), text_value.lower()) >= 75:
                    return self._handle_leaf_option(dispatcher, tracker, opt, language, path_history, option_key=key)

        # Ù…Ù†Ø¹ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¹Ù…ÙŠÙ‚ ÙÙŠ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„ÙØ±Ø¹ÙŠØ© Ù„ØªÙØ§Ø¯ÙŠ Ø§Ù„Ø®Ù„Ø·
        # Ø¨Ø­Ø« Ø¹Ù…ÙŠÙ‚ ÙÙ‚Ø· Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù‚Ø§Ø¦Ù…Ø© ÙØ±Ø¹ÙŠØ©
        if not current_submenu and current_menu == "main":
            deep_option = search_all_levels(user_message, main_menu)
            if deep_option:
                return self._handle_leaf_option(dispatcher, tracker, deep_option, language, path_history)

        # Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø®ÙŠØ§Ø± ØµØ­ÙŠØ­ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ø¹ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
        menu_data = list_options(current_menu, main_menu=main_menu, TITLES=TITLES, EMOJIS=EMOJIS, language=language)
        dispatcher.utter_message(response="utter_invalid_option")
        dispatcher.utter_message(text=menu_data["text"], buttons=menu_data.get("buttons", []))
        return [
            SlotSet("current_menu", "main"),
            SlotSet("current_submenu", None),
            SlotSet("menu_path_history", []),
            SlotSet("awaiting_confirmation", False)
        ]


class ActionBack(Action):
    def name(self) -> Text:
        return "action_back"

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: DomainDict
    ) -> List[Dict[Text, Any]]:

        language = tracker.get_slot("language") or "ar"
        main_menu = get_main_menu(tracker)
        TITLES, EMOJIS = get_titles_emojis(language)
        path_history = tracker.get_slot("menu_path_history") or []

        print(f"DEBUG path_history: {path_history}")
        print(f"DEBUG current language: {language}")

        # ğŸŸ¨ Ø§Ù„Ø­Ø§Ù„Ø© 1: Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø®Ø·ÙˆØ© Ù„Ù„Ø®Ù„Ù Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯ Ø£ÙƒØ«Ø± Ù…Ù† Ø¹Ù†ØµØ±
        if len(path_history) > 1:
            updated_path = path_history[:-1]  # Ù†Ø£Ø®Ø° Ù†Ø³Ø®Ø© Ø¯ÙˆÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ØµÙ„
            print(f"DEBUG updated_path for back: {updated_path}")

            try:
                node = main_menu
                for step in updated_path:
                    node = node.get(step, {})
                    print(f"DEBUG traversing node: {step} -> {node}")
                    if not isinstance(node, dict):
                        raise ValueError("Invalid path in menu")

                # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© Ù…Ù† Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                submenu = []
                if "submenu" in node and isinstance(node["submenu"], list):
                    submenu = node["submenu"]
                elif "options" in node and isinstance(node["options"], dict):
                    submenu = list(node["options"].values())

                print(f"DEBUG submenu after back: {submenu}")

                if submenu:
                    submenu_data = list_options(
                        submenu=submenu,
                        language=language,
                        menu_key=updated_path[-1] if updated_path else None
                    )
                    dispatcher.utter_message(
                        text="â†©ï¸ ØªÙ… Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:" if language == "ar"
                        else "â†©ï¸ Returned to the previous menu:",
                        buttons=submenu_data.get("buttons", [])
                    )
                    dispatcher.utter_message(text=submenu_data["text"])

                    return [
                        SlotSet("current_submenu", submenu),
                        SlotSet("current_menu_section", updated_path[-1] if updated_path else None),
                        SlotSet("menu_path_history", updated_path),
                        SlotSet("awaiting_confirmation", False, 50)
                    ]
                else:
                    menu_data = list_options(
                        "main", main_menu=main_menu,
                        TITLES=TITLES, EMOJIS=EMOJIS, language=language
                    )
                    dispatcher.utter_message(text=menu_data["text"], buttons=menu_data.get("buttons", []))
                    print("DEBUG no submenu found, returning to main menu")
                    return [
                        SlotSet("current_menu", "main"),
                        SlotSet("current_submenu", None),
                        SlotSet("current_menu_section", None),
                        SlotSet("menu_path_history", []),
                        SlotSet("awaiting_confirmation", False, 50)
                    ]

            except Exception as e:
                print(f"DEBUG Exception in ActionBack: {e}")
                dispatcher.utter_message(
                    text="âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø¬ÙˆØ¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ù† Ø¬Ø¯ÙŠØ¯." if language == "ar"
                    else "âš ï¸ An error occurred while going back. Please try again."
                )
                return []

        # ğŸŸ© Ø§Ù„Ø­Ø§Ù„Ø© 2: ÙŠÙˆØ¬Ø¯ Ø®Ø·ÙˆØ© ÙˆØ§Ø­Ø¯Ø© â†’ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        elif len(path_history) == 1:
            menu_data = list_options(
                "main", main_menu=main_menu,
                TITLES=TITLES, EMOJIS=EMOJIS, language=language
            )
            dispatcher.utter_message(
                text="ğŸ”™ Ø¹Ø¯Øª Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:" if language == "ar"
                else "ğŸ”™ Returned to the main menu:",
                buttons=menu_data.get("buttons", [])
            )
            dispatcher.utter_message(text=menu_data["text"])
            print("DEBUG returning to main menu from single path element")
            return [
                SlotSet("current_menu", "main"),
                SlotSet("current_submenu", None),
                SlotSet("current_menu_section", None),
                SlotSet("menu_path_history", []),
                SlotSet("awaiting_confirmation", False, 50)
            ]

        # ğŸŸ¥ Ø§Ù„Ø­Ø§Ù„Ø© 3: Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£ÙŠ Ù…Ø³Ø§Ø± â†’ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø±Ø¬ÙˆØ¹
        else:
            print("DEBUG already at main menu, cannot go back")
            dispatcher.utter_message(
                response="utter_already_main_menu"
            )
            return []




class ActionDefaultFallback(Action):
    def name(self) -> Text:
        return "action_default_fallback"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        language = tracker.get_slot("language") or "ar"
        user_message = tracker.latest_message.get("text", "")
        user_intent = tracker.latest_message.get("intent", {}).get("name")

        # Debug information
        print(f"DEBUG ActionDefaultFallback triggered")
        print(f"DEBUG user_message: '{user_message}'")
        print(f"DEBUG detected_intent: '{user_intent}'")
        print(f"DEBUG language: '{language}'")

        if language == "ar":
            dispatcher.utter_message(text="â“ Ø¹Ø°Ø±Ù‹Ø§ØŒ Ù„Ù… Ø£ÙÙ‡Ù… Ø·Ù„Ø¨Ùƒ. Ù‡Ù„ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© ØµÙŠØ§ØºØªÙ‡ØŸ")
        else:
            dispatcher.utter_message(text="â“ Sorry, I didn't understand that. Can you rephrase it?")

        return []
